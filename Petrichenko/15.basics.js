"Use strict"

// Навигация по DOM дереву
// если есть задача взять элемент и обратиться к его родителю или к следующему элементу и у них поменять класс
console.log(document.body); // обращение к элементу body
console.log(document.head); // обращение к элементу head
console.log(document.documentElement); // обращение к элементу html
// родительский элемент это тот который объединяет другие, находящиеся внутри него
// их мы тоже можем получить с помощью 3х команд
console.log(document.body.childNodes); // получаем узлы, которые являются детьми у body
// в консоле браузера мы получаем псевдомассив NodeList, и псевдомассив из 8 элементов
// в псевдомассиве есть текстовые ноды "text" - "== $0" - перенос строки
// когда страница рендерится - у неё есть только 4 childNodes у body, все остальные это динамические

// разница меджу DOM элементами и DOM узлами
// каждая сущность в html структуре будет узлом, но не каждый узел будет элементом
// всё что видит в тегах - это элементы
// <li>1</li> - li - это DOM элемент, но внутри него есть текстовый элемент

// есть два метода которые позволяют получить либо первого ребёнка внутри родителя либо последнего
console.log(document.body.firstChild);
console.log(document.body.lastChild);



// каждый из примеров мы отталкивались от родителя, но сейчас отталкнёмся от любого элемента на странице
// команда которая позволяет получить родителя соседей и детей
console.log(document.querySelector("#current").parentNode); // в консоль получили наш элемент с классом first
console.log(document.querySelector("#current").parentNode.parentNode); // чтобы получить родителя, продублируем команду 2 раза
// в консоль получаем "wrapper"


// в html 5 стандарте появились data атрибуты
// когда мы прописываем некоторые скрипты, нам иногда не хватает ориентиров
// ставить везде id не самый хороший способ
// <li data-current="3">3</li>
// <li data-current>3</li> - такой синтаксис тоже возможен
console.log(document.querySelector("[data-current='3']"));
// представим, что есть задача получить следующий за ним элемент, со значением 4
console.log(document.querySelector("[data-current='3']").nextSibling);
// в консоль мы получим текстовую ноду в виде переноса строки
console.log(document.querySelector("[data-current='3']").previousSibling); // получаем предыдущий элемент


// все 6 методов получают узлы, и мы можем попасть на текстовую ноду, тот же перенос строки
// чтобы этого не случалось, у этих команд есть аналоги, которые говорят, что мы получаем элемент
console.log(document.querySelector("[data-current='3']").nextElementSibling); // даёт нам следующий элемент а не ноду
console.log(document.querySelector("#current").parentElement); // даёт нам следующий элемент а не ноду
console.log(document.body.firstElementChild); // даёт нам следующий элемент а не ноду

// у .childNodes не видим аналога, если мы хотим получить только элементы, такого функционала нет
// иногда его создают вручную
// в редких случаях использовать forEach не получится и придётся использовать for of
// задача перебрать все childNodes которые лежат в body и избавиться от всех текстовых нод
// если вывести console.log(document.body.childNodes); получим псевдоколлекцию и если зайти в первую текстовую ноду
// мы увидим различные свойства, в тч и nodeName - которое мы и будем использовать
for (let node of document.body.childNodes) {
    if (node.nodeName == "#text") {
        continue;
    }
    console.log(node)
}
// если будет комментарий, мы тоже его получим после перебора, тк он не является текстовой нодой