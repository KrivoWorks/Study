"Use strict";

//СВОЙСТВО CLASSLIST И ДЕЛЕГИРОВАНИЕ СОБЫТИЙ
const btns = document.querySelectorAll('button'); // по селектору тега получаем все кнопки
// чтобы обратиться к списку классов, необходимо прописать .classlist
// это свойство которое есть у этого DOM узла
console.log(btns.classlist); // не работает, мы получили псевдомассив, у него нет такого свойства
// нам необходимо обратиться к конкретному элементу
console.log(btns[0].classlist.length); // и дальше через точку прописываем, что нас интересует
// .length - свойство которое позволяет узнать количество классов у элемента
// в консоль попадёт число классов элемента, например 2 или 3

//===================================================================

// методы .classlist
console.log(btns[0].classlist.item()); // поскольку item это действие, нужны круглые скобки
console.log(btns[0].classlist.item(1)); // получим у кнопки класс под номером 2, индекс 1
// в консоле получим имя класса элемента

// часто используемые методы .classlist
console.log(btns[0].classlist.add('red')); // метод добавляющий класс элементу
// во вкладке elements панели разработчиков видим новый класс у элемениа

console.log(btns[0].classlist.remove('blue')); // метод удаляющий класс элемента

console.log(btns[0].classlist.toggle('blue')); // метод позволяющий тоглить классы
// если класс есть у элемента, он будет убран, если его нет - добавлен

console.log(btns[0].classlist.add('red, bubbb')); 
// через запятую можно добавлять, удалять или тоглить несколько классов

//===================================================================

// наличие класса можно использовать как условие
console.log(btns[0].classlist.item(1)); 
// проблема в том, что мы не всегда уверены, что класс находится на нужной позиции
// чтобы избежать этой неопределённости есть ещё один метод .contains
// он проверяет наличие класса на определённом элементе и возвращает булиновое значение
// если класс есть - true если нет - false
if (btns[1].classList.contains('red')) {
    console.log('red');
}

// пример использования - гамбургер меню, при нажатии, элементу добавляется класс
// hamburger - hamburger hamburger_active
// при повторном нажатии, класс убирается и меню скрывается

btns[0].addEventListener('click', () => {
    if (!btns[1].classList.contains('red')) {
    // мы проверяем, что такого класса у кнопки нет
        btns[1].classList.add('red');
    } else {
        btns[1].classList.remove('red');
    }
});
// когда кликаем на первую кнопку, проверяем вторую кнопку
// если у второй кнопки нет класса red мы его добавляем
// если класс red есть у кнопки мы его удаляем

btns[0].addEventListener('click', () => {
    btns[1].classList.toggle('red');
});
// код тоже работает, в toggle содержится такая же логическая конструкция
// но в сложных скриптах такое поведение не всегда доступно, 
// иногда нужно вручную проверить какой-то класс

// свойство .classname устарело, оно содержит в себе классы в виде одной строки
console.log(btns[0].className); // в консоле будет например - blue some
// чтобы манипулировать этими классами придётся постоянно изменить эту строчку


//===================================================================


// ДЕЛЕГИРОВАНИЕ СОБЫТИЙ
// на странице много кнопок, задача - при клике на каждую, вызывалось одно и тоже событие
// и можем взять обработчик событий и повесить на каждую из них отдельно
// но если кнопки или другие элементы будут добавляться без нашего участия
// то событий у них уже не будет, ведь они не обрабатываются циклом, 
// где мы назначаем обработчик на каждую из них 

// мы берём элемент для всех этих кнопок, допустим плашка за ними, и работаем с ним
// мы назначаем обработчик событий на эту серую плашку, 
// а внутри будем проверять на ччто мы кликнули
// мы назначаем функцию для его потомков, если они подходят под наши параметры

// ПРИМЕР
// школьный класс - если поступать не рационально, нам нужно каждому ученику говорить, 
// что по сб нужн убирать территорию школы, а если в этом классе появляются новые ученики,
// они об этом просто гне будут знать, но если применим делегирование, попросим
// классного руководителя сообщить всем эту информацию, в тч и новым ученикам

const btns2 = document.querySelectorAll('button'), // получаем все кнопки
      wrapper = document.querySelector('.btn-block'); // получаем родителя по селектору класса

// назначим обработчик событий на wrapper
wrapper.addEventListener('click', (event) => { // event - объект события
// он содержит в себе всю информацию о том элементе на котором происходит событие
    console.dir(event.target); // увидим event.target в качестве объекта
    if (event.target && event.target.tagName == "BUTTON") { 
    // удостоверимся, что точно нажали на кнопку
    // если нажмём на кнопку - увидим в консоле - button
    // и раскроем всю информацию об объекте - увидим всю информацию которая есть у DOM узла
    // и интересное свойство которое называется - tagName
    // это название тега который используется в html структуре
    // чтобы удостовериться, что я попал в кнопку и нужно проверить это свойство объекта
    // небольшая особенность, что это свойство всегда пишется в верхнем регистре

    // зачем нужно было прописывать event.target в условии ?
    // в html структуре не все элементы поддерживаются для клика
    // существуют некоторые элементы которые просто невозможно кликнуть
    // поэтому у них просто не будет существовать event.target
    // классический пример - тег <br/> который делает переносы
        console.log('Hello'); // при нажатии на кнопку мы будем получать надпись 'Hello'
    // здесь можно проверять не только tagName но и nodeName, и также классы
    }
});

wrapper.addEventListener('click', (event) => {
    if (event.target && event.target.classList.contains('blue')) {
        console.log('Hello');
    } // если елемент подходит под условие, то на нём будет срабатывать 
// функция которую написали или передали, мы делегируем событие с родителя наа его потомков
}); // теперь можно добавлять любое количество кнопок и все они будут работать


wrapper.addEventListener('click', (event) => {
    if (event.target && event.target.tagName == 'BUTTON') {
        console.log('Hello');
    }
});
// создадим динамический контент на странице
const btn = document.createElement('button'); // создаём элемент
btn.classList.add('red'); // чтобы увидеть, с помощью classList добавим класс
wrapper.append(btn); // это динамический элемент и он существует только в js файле
// метод .append позвоит поместить элемент в нашу обёртку

// на странице добавилась красная кнопка, созданная после того как назначено делегирование
// при нажатии на все кнопки появляется - 'Hello'


// проверим, что будет при переробе без делегирования
btns.forEach(btn => { // перебираем псевдомассив
    btn.addEventListener('click', () => { // и на каждую кнопку навешиваем обработчик событий
        console.log('Hello');
    });
});

const btn2 = document.createElement('button');
btn2.classList.add('red');
wrapper.append(btn2);
// в результате ничего не происходит
// новая кнопка просто ничего не знает об обработчике событий

// способ который любят в google
wrapper.addEventListener('click', (event) => {
    if (event.target && event.target.matches("button.red")) { 
// вместо .tagName .nodeName можем проверять на определённые совпадения
// .matches - какой-то элемент совпадает с чем то ?
// с чем мы и будем сравнивать, нужно указать в круглых скобках
// button - наш тег, .red - у которого будет класс red
        console.log('Hello');
    }
});